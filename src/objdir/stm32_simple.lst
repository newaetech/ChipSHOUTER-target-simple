   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.eabi_attribute 28, 1
   5              		.fpu fpv4-sp-d16
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 4
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.thumb
  16              		.file	"stm32_simple.c"
  17              		.text
  18              	.Ltext0:
  19              		.cfi_sections	.debug_frame
  20              		.section	.text.delay100ms,"ax",%progbits
  21              		.align	1
  22              		.global	delay100ms
  23              		.thumb
  24              		.thumb_func
  26              	delay100ms:
  27              	.LFB124:
  28              		.file 1 "stm32_simple.c"
   1:stm32_simple.c **** /*_
   2:stm32_simple.c **** 	This file is part of the ChipWhisperer Example Targets
   3:stm32_simple.c **** 	Copyright (C) 2012-2017 NewAE Technology Inc.
   4:stm32_simple.c **** 
   5:stm32_simple.c **** 	This program is free software: you can redistribute it and/or modify
   6:stm32_simple.c **** 	it under the terms of the GNU General Public License as published by
   7:stm32_simple.c **** 	the Free Software Foundation, either version 3 of the License, or
   8:stm32_simple.c **** 	(at your option) any later version.
   9:stm32_simple.c **** 
  10:stm32_simple.c **** 	This program is distributed in the hope that it will be useful,
  11:stm32_simple.c **** 	but WITHOUT ANY WARRANTY; without even the implied warranty of
  12:stm32_simple.c **** 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  13:stm32_simple.c **** 	GNU General Public License for more details.
  14:stm32_simple.c **** 
  15:stm32_simple.c **** 	You should have received a copy of the GNU General Public License
  16:stm32_simple.c **** 	along with this program.  If not, see <http://www.gnu.org/licenses/>.
  17:stm32_simple.c **** */
  18:stm32_simple.c **** 
  19:stm32_simple.c **** #include "hal.h"
  20:stm32_simple.c **** #include <stdint.h>
  21:stm32_simple.c **** #include <stdlib.h>
  22:stm32_simple.c **** 
  23:stm32_simple.c **** volatile uint8_t glitched = 0;
  24:stm32_simple.c **** void delay100ms(uint32_t s);
  25:stm32_simple.c **** 
  26:stm32_simple.c **** //clock constants
  27:stm32_simple.c **** #define DIV_HSI_512 1
  28:stm32_simple.c **** 
  29:stm32_simple.c **** //glitch() constants
  30:stm32_simple.c **** #define RUN_CNT 300
  31:stm32_simple.c **** #define GLITCH_CNT 3
  32:stm32_simple.c **** #define LED_DUTY_CYCLE 10
  33:stm32_simple.c **** 
  34:stm32_simple.c **** #define OUTER_LOOP_CNT 100
  35:stm32_simple.c **** 
  36:stm32_simple.c **** #ifdef DIV_HSI_512
  37:stm32_simple.c **** #define INNER_LOOP_CNT 9
  38:stm32_simple.c **** #else
  39:stm32_simple.c **** #define INNER_LOOP_CNT 5000
  40:stm32_simple.c **** #endif
  41:stm32_simple.c **** 
  42:stm32_simple.c **** //delay500ms() constants
  43:stm32_simple.c **** #ifdef DIV_HSI_512
  44:stm32_simple.c **** #define BLINK_PERIOD 129
  45:stm32_simple.c **** #else
  46:stm32_simple.c **** #define BLINK_PERIOD 66000
  47:stm32_simple.c **** #endif
  48:stm32_simple.c **** 
  49:stm32_simple.c **** //startup_blink() constants
  50:stm32_simple.c **** #define BLINK_TOT 3
  51:stm32_simple.c **** 
  52:stm32_simple.c **** void glitch(void)
  53:stm32_simple.c **** {
  54:stm32_simple.c **** 	volatile uint32_t i, j;
  55:stm32_simple.c **** 	volatile uint32_t cnt;
  56:stm32_simple.c **** 	
  57:stm32_simple.c **** 	volatile uint32_t run_cnt = 0;
  58:stm32_simple.c **** 	volatile uint32_t glitch_cnt = 0;
  59:stm32_simple.c **** 	for(run_cnt = 0; run_cnt < RUN_CNT; run_cnt++){
  60:stm32_simple.c **** 		//run led on
  61:stm32_simple.c **** 		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_4, SET);
  62:stm32_simple.c **** 		for(i = 0, cnt = 0; i < LED_DUTY_CYCLE; i++){
  63:stm32_simple.c **** 			for(j=0; j<INNER_LOOP_CNT; j++) {
  64:stm32_simple.c **** 				cnt++;
  65:stm32_simple.c **** 			}
  66:stm32_simple.c **** 		}
  67:stm32_simple.c **** 		
  68:stm32_simple.c **** 		//run led off
  69:stm32_simple.c **** 		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_4, RESET);
  70:stm32_simple.c **** 		for(; i < OUTER_LOOP_CNT; i++) {
  71:stm32_simple.c **** 			for(j=0; j < INNER_LOOP_CNT; j++){
  72:stm32_simple.c **** 				cnt++;
  73:stm32_simple.c **** 			}
  74:stm32_simple.c **** 		}
  75:stm32_simple.c **** 		
  76:stm32_simple.c **** 		//look for glitch
  77:stm32_simple.c **** 		if (i != OUTER_LOOP_CNT || j != INNER_LOOP_CNT || cnt != (OUTER_LOOP_CNT * INNER_LOOP_CNT)) {
  78:stm32_simple.c **** 			//if glitched, reset the run count and blink the fault LED a few times
  79:stm32_simple.c **** 			for (glitch_cnt = 0; glitch_cnt < GLITCH_CNT; glitch_cnt++) {
  80:stm32_simple.c **** 				HAL_GPIO_WritePin(GPIOB, GPIO_PIN_3, SET);
  81:stm32_simple.c **** 				delay100ms(5);
  82:stm32_simple.c **** 				HAL_GPIO_WritePin(GPIOB, GPIO_PIN_3, RESET);
  83:stm32_simple.c **** 				delay100ms(5);
  84:stm32_simple.c **** 			}
  85:stm32_simple.c **** 			
  86:stm32_simple.c **** 			run_cnt = 0;
  87:stm32_simple.c **** 		}
  88:stm32_simple.c **** 	}
  89:stm32_simple.c **** }
  90:stm32_simple.c **** 
  91:stm32_simple.c **** 
  92:stm32_simple.c **** void delay100ms(uint32_t s)
  93:stm32_simple.c **** {
  29              		.loc 1 93 0
  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 8
  32              		@ frame_needed = 0, uses_anonymous_args = 0
  33              		@ link register save eliminated.
  34              	.LVL0:
  35 0000 82B0     		sub	sp, sp, #8
  36              	.LCFI0:
  37              		.cfi_def_cfa_offset 8
  94:stm32_simple.c **** 	volatile uint32_t blink_time = 0;
  38              		.loc 1 94 0
  39 0002 0023     		movs	r3, #0
  40 0004 0093     		str	r3, [sp]
  95:stm32_simple.c **** 	volatile uint32_t blink_num = 0;
  41              		.loc 1 95 0
  42 0006 0193     		str	r3, [sp, #4]
  43              	.L7:
  96:stm32_simple.c **** 	for (blink_num = 0; blink_num < s; blink_num++)
  44              		.loc 1 96 0
  45 0008 0193     		str	r3, [sp, #4]
  46 000a 019B     		ldr	r3, [sp, #4]
  47 000c 8342     		cmp	r3, r0
  48 000e 0AD2     		bcs	.L9
  97:stm32_simple.c **** 		for (blink_time = 0; blink_time < BLINK_PERIOD; blink_time++);
  49              		.loc 1 97 0
  50 0010 0023     		movs	r3, #0
  51              	.L6:
  52              		.loc 1 97 0 is_stmt 0 discriminator 2
  53 0012 0093     		str	r3, [sp]
  54 0014 009B     		ldr	r3, [sp]
  55 0016 802B     		cmp	r3, #128
  56 0018 02D8     		bhi	.L10
  57 001a 009B     		ldr	r3, [sp]
  58 001c 0133     		adds	r3, r3, #1
  59 001e F8E7     		b	.L6
  60              	.L10:
  96:stm32_simple.c **** 	for (blink_num = 0; blink_num < s; blink_num++)
  61              		.loc 1 96 0 is_stmt 1
  62 0020 019B     		ldr	r3, [sp, #4]
  63 0022 0133     		adds	r3, r3, #1
  64 0024 F0E7     		b	.L7
  65              	.L9:
  98:stm32_simple.c **** }
  66              		.loc 1 98 0
  67 0026 02B0     		add	sp, sp, #8
  68              		@ sp needed
  69 0028 7047     		bx	lr
  70              		.cfi_endproc
  71              	.LFE124:
  73              		.section	.text.glitch,"ax",%progbits
  74              		.align	1
  75              		.global	glitch
  76              		.thumb
  77              		.thumb_func
  79              	glitch:
  80              	.LFB123:
  53:stm32_simple.c **** 	volatile uint32_t i, j;
  81              		.loc 1 53 0
  82              		.cfi_startproc
  83              		@ args = 0, pretend = 0, frame = 24
  84              		@ frame_needed = 0, uses_anonymous_args = 0
  85 0000 7FB5     		push	{r0, r1, r2, r3, r4, r5, r6, lr}
  86              	.LCFI1:
  87              		.cfi_def_cfa_offset 32
  88              		.cfi_offset 0, -32
  89              		.cfi_offset 1, -28
  90              		.cfi_offset 2, -24
  91              		.cfi_offset 3, -20
  92              		.cfi_offset 4, -16
  93              		.cfi_offset 5, -12
  94              		.cfi_offset 6, -8
  95              		.cfi_offset 14, -4
  57:stm32_simple.c **** 	volatile uint32_t glitch_cnt = 0;
  96              		.loc 1 57 0
  97 0002 0023     		movs	r3, #0
  98 0004 0493     		str	r3, [sp, #16]
  58:stm32_simple.c **** 	for(run_cnt = 0; run_cnt < RUN_CNT; run_cnt++){
  99              		.loc 1 58 0
 100 0006 0593     		str	r3, [sp, #20]
 101              	.L32:
  59:stm32_simple.c **** 		//run led on
 102              		.loc 1 59 0
 103 0008 0493     		str	r3, [sp, #16]
 104 000a 049B     		ldr	r3, [sp, #16]
 105 000c B3F5967F 		cmp	r3, #300
 106 0010 57D2     		bcs	.L33
  61:stm32_simple.c **** 		for(i = 0, cnt = 0; i < LED_DUTY_CYCLE; i++){
 107              		.loc 1 61 0
 108 0012 2D48     		ldr	r0, .L39
 109 0014 1021     		movs	r1, #16
 110 0016 0122     		movs	r2, #1
 111 0018 FFF7FEFF 		bl	HAL_GPIO_WritePin
 112              	.LVL1:
  62:stm32_simple.c **** 			for(j=0; j<INNER_LOOP_CNT; j++) {
 113              		.loc 1 62 0
 114 001c 0023     		movs	r3, #0
 115 001e 0193     		str	r3, [sp, #4]
 116 0020 0393     		str	r3, [sp, #12]
 117              	.L13:
  62:stm32_simple.c **** 			for(j=0; j<INNER_LOOP_CNT; j++) {
 118              		.loc 1 62 0 is_stmt 0 discriminator 1
 119 0022 019B     		ldr	r3, [sp, #4]
 120 0024 092B     		cmp	r3, #9
 121 0026 0ED8     		bhi	.L34
  63:stm32_simple.c **** 				cnt++;
 122              		.loc 1 63 0 is_stmt 1
 123 0028 0023     		movs	r3, #0
 124              	.L29:
  63:stm32_simple.c **** 				cnt++;
 125              		.loc 1 63 0 is_stmt 0 discriminator 2
 126 002a 0293     		str	r3, [sp, #8]
 127 002c 029B     		ldr	r3, [sp, #8]
 128 002e 082B     		cmp	r3, #8
 129 0030 05D8     		bhi	.L35
  64:stm32_simple.c **** 			}
 130              		.loc 1 64 0 is_stmt 1 discriminator 2
 131 0032 039B     		ldr	r3, [sp, #12]
 132 0034 0133     		adds	r3, r3, #1
 133 0036 0393     		str	r3, [sp, #12]
  63:stm32_simple.c **** 				cnt++;
 134              		.loc 1 63 0 discriminator 2
 135 0038 029B     		ldr	r3, [sp, #8]
 136 003a 0133     		adds	r3, r3, #1
 137 003c F5E7     		b	.L29
 138              	.L35:
  62:stm32_simple.c **** 			for(j=0; j<INNER_LOOP_CNT; j++) {
 139              		.loc 1 62 0
 140 003e 019B     		ldr	r3, [sp, #4]
 141 0040 0133     		adds	r3, r3, #1
 142 0042 0193     		str	r3, [sp, #4]
 143 0044 EDE7     		b	.L13
 144              	.L34:
  69:stm32_simple.c **** 		for(; i < OUTER_LOOP_CNT; i++) {
 145              		.loc 1 69 0
 146 0046 2048     		ldr	r0, .L39
 147 0048 1021     		movs	r1, #16
 148 004a 0022     		movs	r2, #0
 149 004c FFF7FEFF 		bl	HAL_GPIO_WritePin
 150              	.LVL2:
 151              	.L17:
  70:stm32_simple.c **** 			for(j=0; j < INNER_LOOP_CNT; j++){
 152              		.loc 1 70 0 discriminator 1
 153 0050 019B     		ldr	r3, [sp, #4]
 154 0052 632B     		cmp	r3, #99
 155 0054 0ED8     		bhi	.L36
  71:stm32_simple.c **** 				cnt++;
 156              		.loc 1 71 0
 157 0056 0023     		movs	r3, #0
 158              	.L30:
  71:stm32_simple.c **** 				cnt++;
 159              		.loc 1 71 0 is_stmt 0 discriminator 2
 160 0058 0293     		str	r3, [sp, #8]
 161 005a 029B     		ldr	r3, [sp, #8]
 162 005c 082B     		cmp	r3, #8
 163 005e 05D8     		bhi	.L37
  72:stm32_simple.c **** 			}
 164              		.loc 1 72 0 is_stmt 1 discriminator 2
 165 0060 039B     		ldr	r3, [sp, #12]
 166 0062 0133     		adds	r3, r3, #1
 167 0064 0393     		str	r3, [sp, #12]
  71:stm32_simple.c **** 				cnt++;
 168              		.loc 1 71 0 discriminator 2
 169 0066 029B     		ldr	r3, [sp, #8]
 170 0068 0133     		adds	r3, r3, #1
 171 006a F5E7     		b	.L30
 172              	.L37:
  70:stm32_simple.c **** 			for(j=0; j < INNER_LOOP_CNT; j++){
 173              		.loc 1 70 0
 174 006c 019B     		ldr	r3, [sp, #4]
 175 006e 0133     		adds	r3, r3, #1
 176 0070 0193     		str	r3, [sp, #4]
 177 0072 EDE7     		b	.L17
 178              	.L36:
  77:stm32_simple.c **** 			//if glitched, reset the run count and blink the fault LED a few times
 179              		.loc 1 77 0
 180 0074 019B     		ldr	r3, [sp, #4]
 181 0076 642B     		cmp	r3, #100
 182 0078 06D1     		bne	.L21
  77:stm32_simple.c **** 			//if glitched, reset the run count and blink the fault LED a few times
 183              		.loc 1 77 0 is_stmt 0 discriminator 1
 184 007a 029B     		ldr	r3, [sp, #8]
 185 007c 092B     		cmp	r3, #9
 186 007e 03D1     		bne	.L21
 187 0080 039B     		ldr	r3, [sp, #12]
 188 0082 B3F5617F 		cmp	r3, #900
 189 0086 19D0     		beq	.L22
 190              	.L21:
  79:stm32_simple.c **** 				HAL_GPIO_WritePin(GPIOB, GPIO_PIN_3, SET);
 191              		.loc 1 79 0 is_stmt 1
 192 0088 0023     		movs	r3, #0
 193              	.L31:
  79:stm32_simple.c **** 				HAL_GPIO_WritePin(GPIOB, GPIO_PIN_3, SET);
 194              		.loc 1 79 0 is_stmt 0 discriminator 2
 195 008a 0593     		str	r3, [sp, #20]
 196 008c 059B     		ldr	r3, [sp, #20]
 197 008e 022B     		cmp	r3, #2
 198 0090 12D8     		bhi	.L38
  80:stm32_simple.c **** 				delay100ms(5);
 199              		.loc 1 80 0 is_stmt 1 discriminator 2
 200 0092 0821     		movs	r1, #8
 201 0094 0122     		movs	r2, #1
 202 0096 0C48     		ldr	r0, .L39
 203 0098 FFF7FEFF 		bl	HAL_GPIO_WritePin
 204              	.LVL3:
  81:stm32_simple.c **** 				HAL_GPIO_WritePin(GPIOB, GPIO_PIN_3, RESET);
 205              		.loc 1 81 0 discriminator 2
 206 009c 0520     		movs	r0, #5
 207 009e FFF7FEFF 		bl	delay100ms
 208              	.LVL4:
  82:stm32_simple.c **** 				delay100ms(5);
 209              		.loc 1 82 0 discriminator 2
 210 00a2 0948     		ldr	r0, .L39
 211 00a4 0821     		movs	r1, #8
 212 00a6 0022     		movs	r2, #0
 213 00a8 FFF7FEFF 		bl	HAL_GPIO_WritePin
 214              	.LVL5:
  83:stm32_simple.c **** 			}
 215              		.loc 1 83 0 discriminator 2
 216 00ac 0520     		movs	r0, #5
 217 00ae FFF7FEFF 		bl	delay100ms
 218              	.LVL6:
  79:stm32_simple.c **** 				HAL_GPIO_WritePin(GPIOB, GPIO_PIN_3, SET);
 219              		.loc 1 79 0 discriminator 2
 220 00b2 059B     		ldr	r3, [sp, #20]
 221 00b4 0133     		adds	r3, r3, #1
 222 00b6 E8E7     		b	.L31
 223              	.L38:
  86:stm32_simple.c **** 		}
 224              		.loc 1 86 0
 225 00b8 0023     		movs	r3, #0
 226 00ba 0493     		str	r3, [sp, #16]
 227              	.L22:
  59:stm32_simple.c **** 		//run led on
 228              		.loc 1 59 0
 229 00bc 049B     		ldr	r3, [sp, #16]
 230 00be 0133     		adds	r3, r3, #1
 231 00c0 A2E7     		b	.L32
 232              	.L33:
  89:stm32_simple.c **** 
 233              		.loc 1 89 0
 234 00c2 07B0     		add	sp, sp, #28
 235              		@ sp needed
 236 00c4 5DF804FB 		ldr	pc, [sp], #4
 237              	.L40:
 238              		.align	2
 239              	.L39:
 240 00c8 00040048 		.word	1207960576
 241              		.cfi_endproc
 242              	.LFE123:
 244              		.section	.text.startup_blink,"ax",%progbits
 245              		.align	1
 246              		.global	startup_blink
 247              		.thumb
 248              		.thumb_func
 250              	startup_blink:
 251              	.LFB125:
  99:stm32_simple.c **** 
 100:stm32_simple.c **** 
 101:stm32_simple.c **** void startup_blink(void)
 102:stm32_simple.c **** {
 252              		.loc 1 102 0
 253              		.cfi_startproc
 254              		@ args = 0, pretend = 0, frame = 8
 255              		@ frame_needed = 0, uses_anonymous_args = 0
 256 0000 07B5     		push	{r0, r1, r2, lr}
 257              	.LCFI2:
 258              		.cfi_def_cfa_offset 16
 259              		.cfi_offset 0, -16
 260              		.cfi_offset 1, -12
 261              		.cfi_offset 2, -8
 262              		.cfi_offset 14, -4
 103:stm32_simple.c **** 	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_4 | GPIO_PIN_5, RESET);
 263              		.loc 1 103 0
 264 0002 1048     		ldr	r0, .L46
 265 0004 3021     		movs	r1, #48
 266 0006 0022     		movs	r2, #0
 267 0008 FFF7FEFF 		bl	HAL_GPIO_WritePin
 268              	.LVL7:
 104:stm32_simple.c **** 	volatile uint32_t blink_num;
 105:stm32_simple.c **** 	for (blink_num = 0; blink_num < BLINK_TOT; blink_num++) {
 269              		.loc 1 105 0
 270 000c 0023     		movs	r3, #0
 271              	.L44:
 272              		.loc 1 105 0 is_stmt 0 discriminator 2
 273 000e 0193     		str	r3, [sp, #4]
 274 0010 019B     		ldr	r3, [sp, #4]
 275 0012 022B     		cmp	r3, #2
 276 0014 12D8     		bhi	.L45
 106:stm32_simple.c **** 		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, SET);
 277              		.loc 1 106 0 is_stmt 1 discriminator 2
 278 0016 2021     		movs	r1, #32
 279 0018 0122     		movs	r2, #1
 280 001a 0A48     		ldr	r0, .L46
 281 001c FFF7FEFF 		bl	HAL_GPIO_WritePin
 282              	.LVL8:
 107:stm32_simple.c **** 		delay100ms(5);
 283              		.loc 1 107 0 discriminator 2
 284 0020 0520     		movs	r0, #5
 285 0022 FFF7FEFF 		bl	delay100ms
 286              	.LVL9:
 108:stm32_simple.c **** 		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, RESET);
 287              		.loc 1 108 0 discriminator 2
 288 0026 0748     		ldr	r0, .L46
 289 0028 2021     		movs	r1, #32
 290 002a 0022     		movs	r2, #0
 291 002c FFF7FEFF 		bl	HAL_GPIO_WritePin
 292              	.LVL10:
 109:stm32_simple.c **** 		delay100ms(5);
 293              		.loc 1 109 0 discriminator 2
 294 0030 0520     		movs	r0, #5
 295 0032 FFF7FEFF 		bl	delay100ms
 296              	.LVL11:
 105:stm32_simple.c **** 		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, SET);
 297              		.loc 1 105 0 discriminator 2
 298 0036 019B     		ldr	r3, [sp, #4]
 299 0038 0133     		adds	r3, r3, #1
 300 003a E8E7     		b	.L44
 301              	.L45:
 110:stm32_simple.c **** 	}
 111:stm32_simple.c **** 	
 112:stm32_simple.c **** }
 302              		.loc 1 112 0
 303 003c 03B0     		add	sp, sp, #12
 304              		@ sp needed
 305 003e 5DF804FB 		ldr	pc, [sp], #4
 306              	.L47:
 307 0042 00BF     		.align	2
 308              	.L46:
 309 0044 00040048 		.word	1207960576
 310              		.cfi_endproc
 311              	.LFE125:
 313              		.section	.text.osc_setup,"ax",%progbits
 314              		.align	1
 315              		.global	osc_setup
 316              		.thumb
 317              		.thumb_func
 319              	osc_setup:
 320              	.LFB126:
 113:stm32_simple.c **** 
 114:stm32_simple.c **** 
 115:stm32_simple.c **** void osc_setup(void)
 116:stm32_simple.c **** {
 321              		.loc 1 116 0
 322              		.cfi_startproc
 323              		@ args = 0, pretend = 0, frame = 64
 324              		@ frame_needed = 0, uses_anonymous_args = 0
 325 0000 10B5     		push	{r4, lr}
 326              	.LCFI3:
 327              		.cfi_def_cfa_offset 8
 328              		.cfi_offset 4, -8
 329              		.cfi_offset 14, -4
 330 0002 90B0     		sub	sp, sp, #64
 331              	.LCFI4:
 332              		.cfi_def_cfa_offset 72
 117:stm32_simple.c **** 	RCC_OscInitTypeDef RCC_OscInitStruct;
 118:stm32_simple.c **** 	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATO
 333              		.loc 1 118 0
 334 0004 0B23     		movs	r3, #11
 119:stm32_simple.c **** 	RCC_OscInitStruct.HSEState       = RCC_HSE_OFF;
 335              		.loc 1 119 0
 336 0006 0024     		movs	r4, #0
 118:stm32_simple.c **** 	RCC_OscInitStruct.HSEState       = RCC_HSE_OFF;
 337              		.loc 1 118 0
 338 0008 0693     		str	r3, [sp, #24]
 120:stm32_simple.c **** 	RCC_OscInitStruct.HSIState       = RCC_HSI_ON;
 121:stm32_simple.c **** 	RCC_OscInitStruct.PLL.PLLSource  = RCC_PLL_NONE;
 122:stm32_simple.c **** 	RCC_OscInitStruct.LSIState		 = RCC_LSI_OFF;
 123:stm32_simple.c **** 	HAL_RCC_OscConfig(&RCC_OscInitStruct);
 339              		.loc 1 123 0
 340 000a 06A8     		add	r0, sp, #24
 120:stm32_simple.c **** 	RCC_OscInitStruct.HSIState       = RCC_HSI_ON;
 341              		.loc 1 120 0
 342 000c 0123     		movs	r3, #1
 343 000e 0A93     		str	r3, [sp, #40]
 119:stm32_simple.c **** 	RCC_OscInitStruct.HSIState       = RCC_HSI_ON;
 344              		.loc 1 119 0
 345 0010 0794     		str	r4, [sp, #28]
 121:stm32_simple.c **** 	RCC_OscInitStruct.LSIState		 = RCC_LSI_OFF;
 346              		.loc 1 121 0
 347 0012 0E94     		str	r4, [sp, #56]
 122:stm32_simple.c **** 	HAL_RCC_OscConfig(&RCC_OscInitStruct);
 348              		.loc 1 122 0
 349 0014 0C94     		str	r4, [sp, #48]
 350              		.loc 1 123 0
 351 0016 FFF7FEFF 		bl	HAL_RCC_OscConfig
 352              	.LVL12:
 124:stm32_simple.c **** 	
 125:stm32_simple.c **** 	#ifdef DIV_HSI_512
 126:stm32_simple.c **** 	//can't use LSI as system clock, but can divide HSI clock
 127:stm32_simple.c **** 	RCC_ClkInitTypeDef clk;
 128:stm32_simple.c **** 	clk.ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK;
 353              		.loc 1 128 0
 354 001a 0323     		movs	r3, #3
 355 001c 0193     		str	r3, [sp, #4]
 129:stm32_simple.c **** 	clk.AHBCLKDivider = RCC_SYSCLK_DIV512; //as slow as possible
 130:stm32_simple.c **** 	clk.SYSCLKSource   = RCC_SYSCLKSOURCE_HSI;
 131:stm32_simple.c **** 	uint32_t flash_latency = 5;
 132:stm32_simple.c **** 	HAL_RCC_ClockConfig(&clk, flash_latency);
 356              		.loc 1 132 0
 357 001e 01A8     		add	r0, sp, #4
 129:stm32_simple.c **** 	clk.AHBCLKDivider = RCC_SYSCLK_DIV512; //as slow as possible
 358              		.loc 1 129 0
 359 0020 F023     		movs	r3, #240
 360              		.loc 1 132 0
 361 0022 0521     		movs	r1, #5
 129:stm32_simple.c **** 	clk.AHBCLKDivider = RCC_SYSCLK_DIV512; //as slow as possible
 362              		.loc 1 129 0
 363 0024 0393     		str	r3, [sp, #12]
 130:stm32_simple.c **** 	uint32_t flash_latency = 5;
 364              		.loc 1 130 0
 365 0026 0294     		str	r4, [sp, #8]
 366              	.LVL13:
 367              		.loc 1 132 0
 368 0028 FFF7FEFF 		bl	HAL_RCC_ClockConfig
 369              	.LVL14:
 133:stm32_simple.c **** 	#endif
 134:stm32_simple.c **** }
 370              		.loc 1 134 0
 371 002c 10B0     		add	sp, sp, #64
 372              		@ sp needed
 373 002e 10BD     		pop	{r4, pc}
 374              		.cfi_endproc
 375              	.LFE126:
 377              		.section	.text.power_setup,"ax",%progbits
 378              		.align	1
 379              		.global	power_setup
 380              		.thumb
 381              		.thumb_func
 383              	power_setup:
 384              	.LFB127:
 135:stm32_simple.c **** 
 136:stm32_simple.c **** void power_setup(void)
 137:stm32_simple.c **** {
 385              		.loc 1 137 0
 386              		.cfi_startproc
 387              		@ args = 0, pretend = 0, frame = 8
 388              		@ frame_needed = 0, uses_anonymous_args = 0
 389              	.LBB2:
 138:stm32_simple.c **** 	__HAL_RCC_PWR_CLK_ENABLE();
 390              		.loc 1 138 0
 391 0000 074B     		ldr	r3, .L50
 392              	.LBE2:
 137:stm32_simple.c **** 	__HAL_RCC_PWR_CLK_ENABLE();
 393              		.loc 1 137 0
 394 0002 07B5     		push	{r0, r1, r2, lr}
 395              	.LCFI5:
 396              		.cfi_def_cfa_offset 16
 397              		.cfi_offset 0, -16
 398              		.cfi_offset 1, -12
 399              		.cfi_offset 2, -8
 400              		.cfi_offset 14, -4
 401              	.LBB3:
 402              		.loc 1 138 0
 403 0004 DA69     		ldr	r2, [r3, #28]
 404 0006 42F08052 		orr	r2, r2, #268435456
 405 000a DA61     		str	r2, [r3, #28]
 406 000c DB69     		ldr	r3, [r3, #28]
 407 000e 03F08053 		and	r3, r3, #268435456
 408 0012 0193     		str	r3, [sp, #4]
 409 0014 019B     		ldr	r3, [sp, #4]
 410              	.LBE3:
 139:stm32_simple.c **** 	HAL_PWR_EnableBkUpAccess();
 411              		.loc 1 139 0
 412 0016 FFF7FEFF 		bl	HAL_PWR_EnableBkUpAccess
 413              	.LVL15:
 140:stm32_simple.c **** }
 414              		.loc 1 140 0
 415 001a 03B0     		add	sp, sp, #12
 416              		@ sp needed
 417 001c 5DF804FB 		ldr	pc, [sp], #4
 418              	.L51:
 419              		.align	2
 420              	.L50:
 421 0020 00100240 		.word	1073876992
 422              		.cfi_endproc
 423              	.LFE127:
 425              		.section	.text.init_GPIOB,"ax",%progbits
 426              		.align	1
 427              		.global	init_GPIOB
 428              		.thumb
 429              		.thumb_func
 431              	init_GPIOB:
 432              	.LFB128:
 141:stm32_simple.c **** 
 142:stm32_simple.c **** void init_GPIOB(void)
 143:stm32_simple.c **** {
 433              		.loc 1 143 0
 434              		.cfi_startproc
 435              		@ args = 0, pretend = 0, frame = 24
 436              		@ frame_needed = 0, uses_anonymous_args = 0
 437 0000 7FB5     		push	{r0, r1, r2, r3, r4, r5, r6, lr}
 438              	.LCFI6:
 439              		.cfi_def_cfa_offset 32
 440              		.cfi_offset 0, -32
 441              		.cfi_offset 1, -28
 442              		.cfi_offset 2, -24
 443              		.cfi_offset 3, -20
 444              		.cfi_offset 4, -16
 445              		.cfi_offset 5, -12
 446              		.cfi_offset 6, -8
 447              		.cfi_offset 14, -4
 448              	.LBB4:
 144:stm32_simple.c **** 	__HAL_RCC_GPIOB_CLK_ENABLE();
 449              		.loc 1 144 0
 450 0002 0C4B     		ldr	r3, .L53
 451              	.LBE4:
 145:stm32_simple.c **** 	GPIO_InitTypeDef GpioInit;
 146:stm32_simple.c **** 	GpioInit.Pin       = GPIO_PIN_5 | GPIO_PIN_4 | GPIO_PIN_3;
 147:stm32_simple.c **** 	GpioInit.Mode      = GPIO_MODE_OUTPUT_PP;
 148:stm32_simple.c **** 	GpioInit.Pull      = GPIO_NOPULL;
 149:stm32_simple.c **** 	GpioInit.Speed     = GPIO_SPEED_HIGH;
 150:stm32_simple.c **** 	HAL_GPIO_Init(GPIOB, &GpioInit);
 452              		.loc 1 150 0
 453 0004 0C48     		ldr	r0, .L53+4
 454              	.LBB5:
 144:stm32_simple.c **** 	__HAL_RCC_GPIOB_CLK_ENABLE();
 455              		.loc 1 144 0
 456 0006 5A69     		ldr	r2, [r3, #20]
 457 0008 42F48022 		orr	r2, r2, #262144
 458 000c 5A61     		str	r2, [r3, #20]
 459 000e 5B69     		ldr	r3, [r3, #20]
 460 0010 03F48023 		and	r3, r3, #262144
 461 0014 0093     		str	r3, [sp]
 462 0016 009B     		ldr	r3, [sp]
 463              	.LBE5:
 146:stm32_simple.c **** 	GpioInit.Mode      = GPIO_MODE_OUTPUT_PP;
 464              		.loc 1 146 0
 465 0018 3823     		movs	r3, #56
 466 001a 0193     		str	r3, [sp, #4]
 147:stm32_simple.c **** 	GpioInit.Pull      = GPIO_NOPULL;
 467              		.loc 1 147 0
 468 001c 0123     		movs	r3, #1
 469 001e 0293     		str	r3, [sp, #8]
 148:stm32_simple.c **** 	GpioInit.Speed     = GPIO_SPEED_HIGH;
 470              		.loc 1 148 0
 471 0020 0023     		movs	r3, #0
 472 0022 0393     		str	r3, [sp, #12]
 473              		.loc 1 150 0
 474 0024 01A9     		add	r1, sp, #4
 149:stm32_simple.c **** 	HAL_GPIO_Init(GPIOB, &GpioInit);
 475              		.loc 1 149 0
 476 0026 0323     		movs	r3, #3
 477 0028 0493     		str	r3, [sp, #16]
 478              		.loc 1 150 0
 479 002a FFF7FEFF 		bl	HAL_GPIO_Init
 480              	.LVL16:
 151:stm32_simple.c **** }
 481              		.loc 1 151 0
 482 002e 07B0     		add	sp, sp, #28
 483              		@ sp needed
 484 0030 5DF804FB 		ldr	pc, [sp], #4
 485              	.L54:
 486              		.align	2
 487              	.L53:
 488 0034 00100240 		.word	1073876992
 489 0038 00040048 		.word	1207960576
 490              		.cfi_endproc
 491              	.LFE128:
 493              		.section	.text.enter_standby,"ax",%progbits
 494              		.align	1
 495              		.global	enter_standby
 496              		.thumb
 497              		.thumb_func
 499              	enter_standby:
 500              	.LFB129:
 152:stm32_simple.c **** 
 153:stm32_simple.c **** void enter_standby(void)
 154:stm32_simple.c **** {
 501              		.loc 1 154 0
 502              		.cfi_startproc
 503              		@ args = 0, pretend = 0, frame = 0
 504              		@ frame_needed = 0, uses_anonymous_args = 0
 505 0000 08B5     		push	{r3, lr}
 506              	.LCFI7:
 507              		.cfi_def_cfa_offset 8
 508              		.cfi_offset 3, -8
 509              		.cfi_offset 14, -4
 155:stm32_simple.c **** 	HAL_PWR_DisablePVD(); //disable power voltage detector
 510              		.loc 1 155 0
 511 0002 FFF7FEFF 		bl	HAL_PWR_DisablePVD
 512              	.LVL17:
 156:stm32_simple.c **** 	HAL_PWR_EnterSTANDBYMode();
 157:stm32_simple.c **** }
 513              		.loc 1 157 0
 514 0006 BDE80840 		pop	{r3, lr}
 156:stm32_simple.c **** 	HAL_PWR_EnterSTANDBYMode();
 515              		.loc 1 156 0
 516 000a FFF7FEBF 		b	HAL_PWR_EnterSTANDBYMode
 517              	.LVL18:
 518              		.cfi_endproc
 519              	.LFE129:
 521              		.section	.text.startup.main,"ax",%progbits
 522              		.align	1
 523              		.global	main
 524              		.thumb
 525              		.thumb_func
 527              	main:
 528              	.LFB130:
 158:stm32_simple.c **** 
 159:stm32_simple.c **** int main(void)
 160:stm32_simple.c **** {
 529              		.loc 1 160 0
 530              		.cfi_startproc
 531              		@ Volatile: function does not return.
 532              		@ args = 0, pretend = 0, frame = 0
 533              		@ frame_needed = 0, uses_anonymous_args = 0
 534 0000 08B5     		push	{r3, lr}
 535              	.LCFI8:
 536              		.cfi_def_cfa_offset 8
 537              		.cfi_offset 3, -8
 538              		.cfi_offset 14, -4
 161:stm32_simple.c **** 	osc_setup();
 539              		.loc 1 161 0
 540 0002 FFF7FEFF 		bl	osc_setup
 541              	.LVL19:
 162:stm32_simple.c **** 	power_setup();
 542              		.loc 1 162 0
 543 0006 FFF7FEFF 		bl	power_setup
 544              	.LVL20:
 163:stm32_simple.c **** 	init_GPIOB();
 545              		.loc 1 163 0
 546 000a FFF7FEFF 		bl	init_GPIOB
 547              	.LVL21:
 164:stm32_simple.c **** 	
 165:stm32_simple.c **** 	startup_blink();
 548              		.loc 1 165 0
 549 000e FFF7FEFF 		bl	startup_blink
 550              	.LVL22:
 166:stm32_simple.c **** 	//enter glitch loop
 167:stm32_simple.c **** 	glitch();
 551              		.loc 1 167 0
 552 0012 FFF7FEFF 		bl	glitch
 553              	.LVL23:
 168:stm32_simple.c **** 	
 169:stm32_simple.c **** 	//enter standby mode
 170:stm32_simple.c **** 	enter_standby();
 554              		.loc 1 170 0
 555 0016 FFF7FEFF 		bl	enter_standby
 556              	.LVL24:
 557              	.L57:
 558 001a FEE7     		b	.L57
 559              		.cfi_endproc
 560              	.LFE130:
 562              		.global	glitched
 563              		.bss
 566              	glitched:
 567 0000 00       		.space	1
 568              		.text
 569              	.Letext0:
 570              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 571              		.file 3 "/usr/include/newlib/stdint.h"
 572              		.file 4 ".././hal/stm32f3/CMSIS/device/stm32f303x8.h"
 573              		.file 5 ".././hal/stm32f3/CMSIS/device/stm32f3xx.h"
 574              		.file 6 ".././hal/stm32f3/stm32f3xx_hal_def.h"
 575              		.file 7 ".././hal/stm32f3/stm32f3xx_hal_rcc.h"
 576              		.file 8 ".././hal/stm32f3/stm32f3xx_hal_gpio.h"
 577              		.file 9 ".././hal/stm32f3/CMSIS/core/core_cm4.h"
 578              		.file 10 ".././hal/stm32f3/stm32f3xx_hal_pwr.h"
 579              		.file 11 ".././hal/stm32f3/stm32f3xx_hal_pwr_ex.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stm32_simple.c
     /tmp/ccoMJJbX.s:21     .text.delay100ms:00000000 $t
     /tmp/ccoMJJbX.s:26     .text.delay100ms:00000000 delay100ms
     /tmp/ccoMJJbX.s:74     .text.glitch:00000000 $t
     /tmp/ccoMJJbX.s:79     .text.glitch:00000000 glitch
     /tmp/ccoMJJbX.s:240    .text.glitch:000000c8 $d
     /tmp/ccoMJJbX.s:245    .text.startup_blink:00000000 $t
     /tmp/ccoMJJbX.s:250    .text.startup_blink:00000000 startup_blink
     /tmp/ccoMJJbX.s:309    .text.startup_blink:00000044 $d
     /tmp/ccoMJJbX.s:314    .text.osc_setup:00000000 $t
     /tmp/ccoMJJbX.s:319    .text.osc_setup:00000000 osc_setup
     /tmp/ccoMJJbX.s:378    .text.power_setup:00000000 $t
     /tmp/ccoMJJbX.s:383    .text.power_setup:00000000 power_setup
     /tmp/ccoMJJbX.s:421    .text.power_setup:00000020 $d
     /tmp/ccoMJJbX.s:426    .text.init_GPIOB:00000000 $t
     /tmp/ccoMJJbX.s:431    .text.init_GPIOB:00000000 init_GPIOB
     /tmp/ccoMJJbX.s:488    .text.init_GPIOB:00000034 $d
     /tmp/ccoMJJbX.s:494    .text.enter_standby:00000000 $t
     /tmp/ccoMJJbX.s:499    .text.enter_standby:00000000 enter_standby
     /tmp/ccoMJJbX.s:522    .text.startup.main:00000000 $t
     /tmp/ccoMJJbX.s:527    .text.startup.main:00000000 main
     /tmp/ccoMJJbX.s:566    .bss:00000000 glitched
     /tmp/ccoMJJbX.s:567    .bss:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
HAL_GPIO_WritePin
HAL_RCC_OscConfig
HAL_RCC_ClockConfig
HAL_PWR_EnableBkUpAccess
HAL_GPIO_Init
HAL_PWR_DisablePVD
HAL_PWR_EnterSTANDBYMode
