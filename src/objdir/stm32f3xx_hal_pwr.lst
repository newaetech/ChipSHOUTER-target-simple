   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.eabi_attribute 28, 1
   5              		.fpu fpv4-sp-d16
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 4
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.thumb
  16              		.file	"stm32f3xx_hal_pwr.c"
  17              		.text
  18              	.Ltext0:
  19              		.cfi_sections	.debug_frame
  20              		.section	.text.HAL_PWR_DeInit,"ax",%progbits
  21              		.align	1
  22              		.global	HAL_PWR_DeInit
  23              		.thumb
  24              		.thumb_func
  26              	HAL_PWR_DeInit:
  27              	.LFB123:
  28              		.file 1 ".././hal/stm32f3/stm32f3xx_hal_pwr.c"
   1:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** /**
   2:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   ******************************************************************************
   3:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @file    stm32f3xx_hal_pwr.c
   4:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @author  MCD Application Team
   5:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @brief   PWR HAL module driver.
   6:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *          This file provides firmware functions to manage the following
   7:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *          functionalities of the Power Controller (PWR) peripheral:
   8:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *           + Initialization/de-initialization functions
   9:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *           + Peripheral Control functions
  10:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *
  11:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   @verbatim
  12:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   ******************************************************************************
  13:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @attention
  14:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *
  15:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
  16:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *
  17:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * Redistribution and use in source and binary forms, with or without modification,
  18:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * are permitted provided that the following conditions are met:
  19:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *   1. Redistributions of source code must retain the above copyright notice,
  20:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *      this list of conditions and the following disclaimer.
  21:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *   2. Redistributions in binary form must reproduce the above copyright notice,
  22:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *      this list of conditions and the following disclaimer in the documentation
  23:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *      and/or other materials provided with the distribution.
  24:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *   3. Neither the name of STMicroelectronics nor the names of its contributors
  25:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *      may be used to endorse or promote products derived from this software
  26:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *      without specific prior written permission.
  27:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *
  28:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  29:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  30:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  31:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  32:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  33:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  34:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  35:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  36:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  37:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  38:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *
  39:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   ******************************************************************************
  40:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   */
  41:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
  42:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** /* Includes ------------------------------------------------------------------*/
  43:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** #include "stm32f3xx_hal.h"
  44:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
  45:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** /** @addtogroup STM32F3xx_HAL_Driver
  46:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @{
  47:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   */
  48:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
  49:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** /** @defgroup PWR PWR
  50:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @brief PWR HAL module driver
  51:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @{
  52:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   */
  53:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
  54:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** #ifdef HAL_PWR_MODULE_ENABLED
  55:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
  56:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** /* Private typedef -----------------------------------------------------------*/
  57:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** /* Private define ------------------------------------------------------------*/
  58:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** /* Private macro -------------------------------------------------------------*/
  59:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** /* Private variables ---------------------------------------------------------*/
  60:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** /* Private function prototypes -----------------------------------------------*/
  61:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** /* Private functions ---------------------------------------------------------*/
  62:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
  63:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** /** @defgroup PWR_Exported_Functions PWR Exported Functions
  64:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @{
  65:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   */
  66:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
  67:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** /** @defgroup PWR_Exported_Functions_Group1 Initialization and de-initialization functions 
  68:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *  @brief    Initialization and de-initialization functions
  69:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *
  70:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** @verbatim
  71:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****  ===============================================================================
  72:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****               ##### Initialization and de-initialization functions #####
  73:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****  ===============================================================================
  74:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****     [..]
  75:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       After reset, the backup domain (RTC registers, RTC backup data
  76:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       registers and backup SRAM) is protected against possible unwanted
  77:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       write accesses.
  78:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       To enable access to the RTC Domain and RTC registers, proceed as follows:
  79:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****         (+) Enable the Power Controller (PWR) APB1 interface clock using the
  80:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****             __HAL_RCC_PWR_CLK_ENABLE() macro.
  81:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****         (+) Enable access to RTC domain using the HAL_PWR_EnableBkUpAccess() function.
  82:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
  83:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** @endverbatim
  84:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @{
  85:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   */
  86:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
  87:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** /**
  88:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @brief Deinitializes the PWR peripheral registers to their default reset values.
  89:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @retval None
  90:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   */
  91:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** void HAL_PWR_DeInit(void)
  92:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** {
  29              		.loc 1 92 0
  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 0
  32              		@ frame_needed = 0, uses_anonymous_args = 0
  33              		@ link register save eliminated.
  93:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   __HAL_RCC_PWR_FORCE_RESET();
  34              		.loc 1 93 0
  35 0000 044B     		ldr	r3, .L2
  36 0002 1A69     		ldr	r2, [r3, #16]
  37 0004 42F08052 		orr	r2, r2, #268435456
  38 0008 1A61     		str	r2, [r3, #16]
  94:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   __HAL_RCC_PWR_RELEASE_RESET();
  39              		.loc 1 94 0
  40 000a 1A69     		ldr	r2, [r3, #16]
  41 000c 22F08052 		bic	r2, r2, #268435456
  42 0010 1A61     		str	r2, [r3, #16]
  43 0012 7047     		bx	lr
  44              	.L3:
  45              		.align	2
  46              	.L2:
  47 0014 00100240 		.word	1073876992
  48              		.cfi_endproc
  49              	.LFE123:
  51              		.section	.text.HAL_PWR_EnableBkUpAccess,"ax",%progbits
  52              		.align	1
  53              		.global	HAL_PWR_EnableBkUpAccess
  54              		.thumb
  55              		.thumb_func
  57              	HAL_PWR_EnableBkUpAccess:
  58              	.LFB124:
  95:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** }
  96:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
  97:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** /**
  98:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @brief Enables access to the backup domain (RTC registers, RTC
  99:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *         backup data registers and backup SRAM).
 100:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @note  If the HSE divided by 32 is used as the RTC clock, the
 101:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *         Backup Domain Access should be kept enabled.
 102:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @retval None
 103:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   */
 104:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** void HAL_PWR_EnableBkUpAccess(void)
 105:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** {
  59              		.loc 1 105 0
  60              		.cfi_startproc
  61              		@ args = 0, pretend = 0, frame = 0
  62              		@ frame_needed = 0, uses_anonymous_args = 0
  63              		@ link register save eliminated.
 106:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   SET_BIT(PWR->CR, PWR_CR_DBP);  
  64              		.loc 1 106 0
  65 0000 024B     		ldr	r3, .L5
  66 0002 1A68     		ldr	r2, [r3]
  67 0004 42F48072 		orr	r2, r2, #256
  68 0008 1A60     		str	r2, [r3]
  69 000a 7047     		bx	lr
  70              	.L6:
  71              		.align	2
  72              	.L5:
  73 000c 00700040 		.word	1073770496
  74              		.cfi_endproc
  75              	.LFE124:
  77              		.section	.text.HAL_PWR_DisableBkUpAccess,"ax",%progbits
  78              		.align	1
  79              		.global	HAL_PWR_DisableBkUpAccess
  80              		.thumb
  81              		.thumb_func
  83              	HAL_PWR_DisableBkUpAccess:
  84              	.LFB125:
 107:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** }
 108:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 109:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** /**
 110:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @brief Disables access to the backup domain (RTC registers, RTC
 111:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *         backup data registers and backup SRAM).
 112:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @note  If the HSE divided by 32 is used as the RTC clock, the
 113:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *         Backup Domain Access should be kept enabled.
 114:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @retval None
 115:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   */
 116:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** void HAL_PWR_DisableBkUpAccess(void)
 117:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** {
  85              		.loc 1 117 0
  86              		.cfi_startproc
  87              		@ args = 0, pretend = 0, frame = 0
  88              		@ frame_needed = 0, uses_anonymous_args = 0
  89              		@ link register save eliminated.
 118:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   CLEAR_BIT(PWR->CR, PWR_CR_DBP);  
  90              		.loc 1 118 0
  91 0000 024B     		ldr	r3, .L8
  92 0002 1A68     		ldr	r2, [r3]
  93 0004 22F48072 		bic	r2, r2, #256
  94 0008 1A60     		str	r2, [r3]
  95 000a 7047     		bx	lr
  96              	.L9:
  97              		.align	2
  98              	.L8:
  99 000c 00700040 		.word	1073770496
 100              		.cfi_endproc
 101              	.LFE125:
 103              		.section	.text.HAL_PWR_EnableWakeUpPin,"ax",%progbits
 104              		.align	1
 105              		.global	HAL_PWR_EnableWakeUpPin
 106              		.thumb
 107              		.thumb_func
 109              	HAL_PWR_EnableWakeUpPin:
 110              	.LFB126:
 119:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** }
 120:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 121:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** /**
 122:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @}
 123:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   */
 124:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 125:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** /** @defgroup PWR_Exported_Functions_Group2 Peripheral Control functions 
 126:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *  @brief Low Power modes configuration functions
 127:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *
 128:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** @verbatim
 129:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 130:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****  ===============================================================================
 131:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****                  ##### Peripheral Control functions #####
 132:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****  ===============================================================================
 133:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****     
 134:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****     *** WakeUp pin configuration ***
 135:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****     ================================
 136:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****     [..]
 137:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       (+) WakeUp pin is used to wakeup the system from Standby mode. This pin is
 138:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****           forced in input pull down configuration and is active on rising edges.
 139:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       (+) There are up to three WakeUp pins:
 140:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****           (++)WakeUp Pin 1 on PA.00.
 141:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****           (++)WakeUp Pin 2 on PC.13 (STM32F303xC, STM32F303xE only).
 142:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****           (++)WakeUp Pin 3 on PE.06.
 143:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 144:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****     *** Main and Backup Regulators configuration ***
 145:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****     ================================================
 146:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****     [..]
 147:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       (+) When the backup domain is supplied by VDD (analog switch connected to VDD)
 148:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****           the backup SRAM is powered from VDD which replaces the VBAT power supply to
 149:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****           save battery life.
 150:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 151:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       (+) The backup SRAM is not mass erased by a tamper event. It is read
 152:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****           protected to prevent confidential data, such as cryptographic private
 153:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****           key, from being accessed. The backup SRAM can be erased only through
 154:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****           the Flash interface when a protection level change from level 1 to
 155:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****           level 0 is requested.
 156:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       -@- Refer to the description of Read protection (RDP) in the Flash
 157:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****           programming manual.
 158:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 159:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****         Refer to the datasheets for more details.
 160:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 161:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****     *** Low Power modes configuration ***
 162:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****     =====================================
 163:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****     [..]
 164:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       The devices feature 3 low-power modes:
 165:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       (+) Sleep mode: Cortex-M4 core stopped, peripherals kept running.
 166:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       (+) Stop mode: all clocks are stopped, regulator running, regulator
 167:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****           in low power mode
 168:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       (+) Standby mode: 1.2V domain powered off (mode not available on STM32F3x8 devices).
 169:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 170:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****    *** Sleep mode ***
 171:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****    ==================
 172:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****     [..]
 173:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       (+) Entry:
 174:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****           The Sleep mode is entered by using the HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_S
 175:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****               functions with
 176:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****           (++) PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction
 177:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****           (++) PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction
 178:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****      
 179:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       (+) Exit:
 180:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****         (++) Any peripheral interrupt acknowledged by the nested vectored interrupt
 181:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****               controller (NVIC) can wake up the device from Sleep mode.
 182:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 183:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****    *** Stop mode ***
 184:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****    =================
 185:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****     [..]
 186:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       In Stop mode, all clocks in the 1.8V domain are stopped, the PLL, the HSI,
 187:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       and the HSE RC oscillators are disabled. Internal SRAM and register contents
 188:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       are preserved.
 189:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       The voltage regulator can be configured either in normal or low-power mode to minimize the co
 190:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 191:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       (+) Entry:
 192:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****           The Stop mode is entered using the HAL_PWR_EnterSTOPMode(PWR_MAINREGULATOR_ON, PWR_STOPEN
 193:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****              function with:
 194:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****           (++) Main regulator ON or
 195:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****           (++) Low Power regulator ON.
 196:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****           (++) PWR_STOPENTRY_WFI: enter STOP mode with WFI instruction or
 197:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****           (++) PWR_STOPENTRY_WFE: enter STOP mode with WFE instruction
 198:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       (+) Exit:
 199:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****           (++) Any EXTI Line (Internal or External) configured in Interrupt/Event mode.
 200:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****           (++) Some specific communication peripherals (CEC, USART, I2C) interrupts, 
 201:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****                when programmed in wakeup mode (the peripheral must be 
 202:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****                programmed in wakeup mode and the corresponding interrupt vector 
 203:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****                must be enabled in the NVIC).
 204:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 205:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****    *** Standby mode ***
 206:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****    ====================
 207:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****      [..]
 208:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       The Standby mode allows to achieve the lowest power consumption. It is based
 209:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       on the Cortex-M4 deep sleep mode, with the voltage regulator disabled.
 210:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       The 1.8V domain is consequently powered off. The PLL, the HSI oscillator and
 211:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       the HSE oscillator are also switched off. SRAM and register contents are lost
 212:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       except for the RTC registers, RTC backup registers, backup SRAM and Standby
 213:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       circuitry.
 214:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       The voltage regulator is OFF.
 215:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 216:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       (+) Entry:
 217:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****           (++) The Standby mode is entered using the HAL_PWR_EnterSTANDBYMode() function.
 218:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       (+) Exit:
 219:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****           (++) WKUP pin rising edge, RTC alarm (Alarm A and Alarm B), RTC wakeup,
 220:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****                tamper event, time-stamp event, external reset in NRST pin, IWDG reset.
 221:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 222:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****    *** Auto-wakeup (AWU) from low-power mode ***
 223:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****    =============================================
 224:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****     [..]
 225:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       The MCU can be woken up from low-power mode by an RTC Alarm event, an RTC
 226:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       Wakeup event, a tamper event, a time-stamp event, or a comparator event, 
 227:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       without depending on an external interrupt (Auto-wakeup mode).
 228:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 229:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****     (+) RTC auto-wakeup (AWU) from the Stop and Standby modes
 230:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 231:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       (++) To wake up from the Stop mode with an RTC alarm event, it is necessary to
 232:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****             configure the RTC to generate the RTC alarm using the HAL_RTC_SetAlarm_IT() function.
 233:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 234:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       (++) To wake up from the Stop mode with an RTC Tamper or time stamp event, it
 235:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****            is necessary to configure the RTC to detect the tamper or time stamp event using the
 236:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****            HAL_RTC_SetTimeStamp_IT() or HAL_RTC_SetTamper_IT() functions.
 237:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 238:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       (++) To wake up from the Stop mode with an RTC WakeUp event, it is necessary to
 239:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****            configure the RTC to generate the RTC WakeUp event using the HAL_RTC_SetWakeUpTimer_IT()
 240:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 241:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****     (+) Comparator auto-wakeup (AWU) from the Stop mode
 242:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 243:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****       (++) To wake up from the Stop mode with a comparator wakeup event, it is necessary to:
 244:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****            (+++) Configure the EXTI Line associated with the comparator (example EXTI Line 22 for c
 245:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****                  to be sensitive to to the selected edges (falling, rising or falling 
 246:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****                  and rising) (Interrupt or Event modes) using the EXTI_Init() function.
 247:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****            (+++) Configure the comparator to generate the event.      
 248:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** @endverbatim
 249:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @{
 250:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   */
 251:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 252:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** /**
 253:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @brief Enables the WakeUp PINx functionality.
 254:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @param WakeUpPinx Specifies the Power Wake-Up pin to enable.
 255:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *         This parameter can be value of :
 256:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *           @ref PWR_WakeUp_Pins
 257:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @retval None
 258:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   */
 259:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** void HAL_PWR_EnableWakeUpPin(uint32_t WakeUpPinx)
 260:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** {
 111              		.loc 1 260 0
 112              		.cfi_startproc
 113              		@ args = 0, pretend = 0, frame = 0
 114              		@ frame_needed = 0, uses_anonymous_args = 0
 115              		@ link register save eliminated.
 116              	.LVL0:
 261:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   /* Check the parameters */
 262:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));
 263:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   /* Enable the EWUPx pin */
 264:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   SET_BIT(PWR->CSR, WakeUpPinx);
 117              		.loc 1 264 0
 118 0000 024B     		ldr	r3, .L11
 119 0002 5A68     		ldr	r2, [r3, #4]
 120 0004 1043     		orrs	r0, r0, r2
 121              	.LVL1:
 122 0006 5860     		str	r0, [r3, #4]
 123 0008 7047     		bx	lr
 124              	.L12:
 125 000a 00BF     		.align	2
 126              	.L11:
 127 000c 00700040 		.word	1073770496
 128              		.cfi_endproc
 129              	.LFE126:
 131              		.section	.text.HAL_PWR_DisableWakeUpPin,"ax",%progbits
 132              		.align	1
 133              		.global	HAL_PWR_DisableWakeUpPin
 134              		.thumb
 135              		.thumb_func
 137              	HAL_PWR_DisableWakeUpPin:
 138              	.LFB127:
 265:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** }
 266:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 267:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** /**
 268:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @brief Disables the WakeUp PINx functionality.
 269:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @param WakeUpPinx Specifies the Power Wake-Up pin to disable.
 270:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *         This parameter can be values of :
 271:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *           @ref PWR_WakeUp_Pins
 272:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @retval None
 273:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   */
 274:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** void HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx)
 275:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** {
 139              		.loc 1 275 0
 140              		.cfi_startproc
 141              		@ args = 0, pretend = 0, frame = 0
 142              		@ frame_needed = 0, uses_anonymous_args = 0
 143              		@ link register save eliminated.
 144              	.LVL2:
 276:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   /* Check the parameters */
 277:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));
 278:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   /* Disable the EWUPx pin */
 279:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   CLEAR_BIT(PWR->CSR, WakeUpPinx);
 145              		.loc 1 279 0
 146 0000 024B     		ldr	r3, .L14
 147 0002 5A68     		ldr	r2, [r3, #4]
 148 0004 22EA0000 		bic	r0, r2, r0
 149              	.LVL3:
 150 0008 5860     		str	r0, [r3, #4]
 151 000a 7047     		bx	lr
 152              	.L15:
 153              		.align	2
 154              	.L14:
 155 000c 00700040 		.word	1073770496
 156              		.cfi_endproc
 157              	.LFE127:
 159              		.section	.text.HAL_PWR_EnterSLEEPMode,"ax",%progbits
 160              		.align	1
 161              		.global	HAL_PWR_EnterSLEEPMode
 162              		.thumb
 163              		.thumb_func
 165              	HAL_PWR_EnterSLEEPMode:
 166              	.LFB128:
 280:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** }
 281:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 282:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** /**
 283:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @brief Enters Sleep mode.
 284:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @note  In Sleep mode, all I/O pins keep the same state as in Run mode.
 285:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @param Regulator Specifies the regulator state in SLEEP mode.
 286:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *          This parameter can be one of the following values:
 287:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *            @arg PWR_MAINREGULATOR_ON: SLEEP mode with regulator ON
 288:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *            @arg PWR_LOWPOWERREGULATOR_ON: SLEEP mode with low power regulator ON
 289:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @note This parameter has no effect in F3 family and is just maintained to 
 290:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *       offer full portability of other STM32 families softwares.
 291:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @param SLEEPEntry Specifies if SLEEP mode is entered with WFI or WFE instruction.
 292:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *           When WFI entry is used, tick interrupt have to be disabled if not desired as 
 293:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *           the interrupt wake up source.
 294:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *           This parameter can be one of the following values:
 295:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *            @arg PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction
 296:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *            @arg PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction
 297:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @retval None
 298:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   */
 299:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)
 300:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** {
 167              		.loc 1 300 0
 168              		.cfi_startproc
 169              		@ args = 0, pretend = 0, frame = 0
 170              		@ frame_needed = 0, uses_anonymous_args = 0
 171              		@ link register save eliminated.
 172              	.LVL4:
 301:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   /* Check the parameters */
 302:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));
 303:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 304:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   /* Clear SLEEPDEEP bit of Cortex System Control Register */
 305:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
 173              		.loc 1 305 0
 174 0000 064B     		ldr	r3, .L20
 175 0002 1A69     		ldr	r2, [r3, #16]
 306:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 307:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   /* Select SLEEP mode entry -------------------------------------------------*/
 308:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   if(SLEEPEntry == PWR_SLEEPENTRY_WFI)
 176              		.loc 1 308 0
 177 0004 0129     		cmp	r1, #1
 305:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 178              		.loc 1 305 0
 179 0006 22F00402 		bic	r2, r2, #4
 180 000a 1A61     		str	r2, [r3, #16]
 181              		.loc 1 308 0
 182 000c 01D1     		bne	.L17
 183              	.LBB20:
 184              	.LBB21:
 185              		.file 2 ".././hal/stm32f3/CMSIS/core/cmsis_gcc.h"
   1:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /**************************************************************************//**
   2:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  * @brief    CMSIS Cortex-M Core Function/Instruction Header File
   4:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  * @version  V4.30
   5:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  * @date     20. October 2015
   6:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  ******************************************************************************/
   7:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /* Copyright (c) 2009 - 2015 ARM LIMITED
   8:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
   9:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****    All rights reserved.
  10:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****    Redistribution and use in source and binary forms, with or without
  11:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****    modification, are permitted provided that the following conditions are met:
  12:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****    - Redistributions of source code must retain the above copyright
  13:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****      notice, this list of conditions and the following disclaimer.
  14:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****    - Redistributions in binary form must reproduce the above copyright
  15:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****      notice, this list of conditions and the following disclaimer in the
  16:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****      documentation and/or other materials provided with the distribution.
  17:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****    - Neither the name of ARM nor the names of its contributors may be used
  18:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****      to endorse or promote products derived from this software without
  19:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****      specific prior written permission.
  20:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****    *
  21:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****    ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  25:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****    POSSIBILITY OF SUCH DAMAGE.
  32:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****    ---------------------------------------------------------------------------*/
  33:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
  34:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
  35:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  36:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** #define __CMSIS_GCC_H
  37:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
  38:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /* ignore some GCC warnings */
  39:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** #if defined ( __GNUC__ )
  40:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** #pragma GCC diagnostic push
  41:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  42:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  43:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  44:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** #endif
  45:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
  46:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
  47:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
  48:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
  49:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
  50:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   @{
  51:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  */
  52:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
  53:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /**
  54:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
  55:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
  56:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****            Can only be executed in Privileged modes.
  57:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  */
  58:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
  59:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** {
  60:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
  61:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
  62:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
  63:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
  64:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /**
  65:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
  66:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  67:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   Can only be executed in Privileged modes.
  68:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  */
  69:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
  70:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** {
  71:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
  72:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
  73:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
  74:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
  75:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /**
  76:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \brief   Get Control Register
  77:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \details Returns the content of the Control Register.
  78:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \return               Control Register value
  79:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  */
  80:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
  81:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** {
  82:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   uint32_t result;
  83:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
  84:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
  85:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   return(result);
  86:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
  87:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
  88:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
  89:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /**
  90:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \brief   Set Control Register
  91:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
  92:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
  93:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  */
  94:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
  95:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** {
  96:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
  97:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
  98:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
  99:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 100:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /**
 101:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \brief   Get IPSR Register
 102:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 103:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \return               IPSR Register value
 104:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  */
 105:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
 106:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** {
 107:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   uint32_t result;
 108:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 109:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 110:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   return(result);
 111:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
 112:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 113:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 114:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /**
 115:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \brief   Get APSR Register
 116:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 117:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \return               APSR Register value
 118:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  */
 119:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
 120:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** {
 121:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   uint32_t result;
 122:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 123:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 124:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   return(result);
 125:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
 126:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 127:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 128:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /**
 129:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \brief   Get xPSR Register
 130:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 131:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 132:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****     \return               xPSR Register value
 133:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  */
 134:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
 135:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** {
 136:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   uint32_t result;
 137:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 138:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 139:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   return(result);
 140:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
 141:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 142:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 143:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /**
 144:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 145:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 146:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \return               PSP Register value
 147:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  */
 148:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
 149:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** {
 150:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   register uint32_t result;
 151:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 152:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 153:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   return(result);
 154:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
 155:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 156:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 157:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /**
 158:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 159:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 160:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 161:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  */
 162:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
 163:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** {
 164:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 165:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
 166:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 167:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 168:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /**
 169:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 170:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 171:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \return               MSP Register value
 172:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  */
 173:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
 174:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** {
 175:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   register uint32_t result;
 176:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 177:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
 178:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   return(result);
 179:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
 180:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 181:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 182:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /**
 183:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 184:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 185:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 186:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****     \param [in]    topOfMainStack  Main Stack Pointer value to set
 187:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  */
 188:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
 189:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** {
 190:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
 191:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
 192:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 193:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 194:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /**
 195:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \brief   Get Priority Mask
 196:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 197:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \return               Priority Mask value
 198:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  */
 199:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
 200:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** {
 201:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   uint32_t result;
 202:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 203:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) );
 204:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   return(result);
 205:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
 206:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 207:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 208:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /**
 209:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \brief   Set Priority Mask
 210:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 211:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 212:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  */
 213:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
 214:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** {
 215:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 216:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
 217:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 218:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 219:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** #if       (__CORTEX_M >= 0x03U)
 220:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 221:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /**
 222:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \brief   Enable FIQ
 223:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 224:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 225:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  */
 226:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
 227:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** {
 228:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 229:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
 230:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 231:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 232:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /**
 233:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \brief   Disable FIQ
 234:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 235:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 236:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  */
 237:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
 238:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** {
 239:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 240:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
 241:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 242:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 243:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /**
 244:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \brief   Get Base Priority
 245:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 246:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \return               Base Priority register value
 247:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  */
 248:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
 249:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** {
 250:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   uint32_t result;
 251:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 252:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 253:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   return(result);
 254:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
 255:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 256:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 257:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /**
 258:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \brief   Set Base Priority
 259:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 260:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 261:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  */
 262:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
 263:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** {
 264:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 265:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
 266:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 267:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 268:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /**
 269:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 270:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 271:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 272:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 273:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  */
 274:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI_MAX(uint32_t value)
 275:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** {
 276:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (value) : "memory");
 277:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
 278:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 279:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 280:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /**
 281:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \brief   Get Fault Mask
 282:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 283:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \return               Fault Mask register value
 284:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  */
 285:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
 286:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** {
 287:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   uint32_t result;
 288:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 289:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 290:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   return(result);
 291:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
 292:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 293:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 294:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /**
 295:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \brief   Set Fault Mask
 296:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 297:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 298:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  */
 299:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
 300:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** {
 301:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 302:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
 303:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 304:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** #endif /* (__CORTEX_M >= 0x03U) */
 305:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 306:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 307:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** #if       (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U)
 308:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 309:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /**
 310:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \brief   Get FPSCR
 311:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 312:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 313:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  */
 314:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
 315:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** {
 316:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** #if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
 317:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   uint32_t result;
 318:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 319:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   /* Empty asm statement works as a scheduling barrier */
 320:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("");
 321:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 322:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("");
 323:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   return(result);
 324:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** #else
 325:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****    return(0);
 326:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** #endif
 327:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
 328:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 329:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 330:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /**
 331:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \brief   Set FPSCR
 332:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 333:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 334:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  */
 335:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
 336:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** {
 337:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** #if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
 338:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   /* Empty asm statement works as a scheduling barrier */
 339:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("");
 340:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
 341:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("");
 342:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** #endif
 343:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
 344:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 345:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** #endif /* (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U) */
 346:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 347:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 348:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 349:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 350:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 351:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 352:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 353:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 354:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   Access to dedicated instructions
 355:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   @{
 356:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** */
 357:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 358:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 359:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 360:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 361:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 362:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 363:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 364:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** #else
 365:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 366:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 367:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** #endif
 368:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 369:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /**
 370:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \brief   No Operation
 371:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 372:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  */
 373:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
 374:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** {
 375:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("nop");
 376:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
 377:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 378:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 379:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /**
 380:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \brief   Wait For Interrupt
 381:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 382:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  */
 383:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
 384:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** {
 385:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("wfi");
 186              		.loc 2 385 0
 187              	@ 385 ".././hal/stm32f3/CMSIS/core/cmsis_gcc.h" 1
 188 000e 30BF     		wfi
 189              	@ 0 "" 2
 190              		.thumb
 191 0010 7047     		bx	lr
 192              	.L17:
 193              	.LBE21:
 194              	.LBE20:
 195              	.LBB22:
 196              	.LBB23:
 386:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
 387:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 388:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 389:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /**
 390:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \brief   Wait For Event
 391:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 392:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****     a low-power state until one of a number of events occurs.
 393:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  */
 394:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
 395:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** {
 396:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("wfe");
 397:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
 398:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 399:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** 
 400:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** /**
 401:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \brief   Send Event
 402:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 403:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****  */
 404:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
 405:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** {
 406:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h ****   __ASM volatile ("sev");
 197              		.loc 2 406 0
 198              	@ 406 ".././hal/stm32f3/CMSIS/core/cmsis_gcc.h" 1
 199 0012 40BF     		sev
 200              	@ 0 "" 2
 201              		.thumb
 202              	.LBE23:
 203              	.LBE22:
 204              	.LBB24:
 205              	.LBB25:
 396:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
 206              		.loc 2 396 0
 207              	@ 396 ".././hal/stm32f3/CMSIS/core/cmsis_gcc.h" 1
 208 0014 20BF     		wfe
 209              	@ 0 "" 2
 210              		.thumb
 211              	.LBE25:
 212              	.LBE24:
 213              	.LBB26:
 214              	.LBB27:
 215              	@ 396 ".././hal/stm32f3/CMSIS/core/cmsis_gcc.h" 1
 216 0016 20BF     		wfe
 217              	@ 0 "" 2
 218              		.thumb
 219 0018 7047     		bx	lr
 220              	.L21:
 221 001a 00BF     		.align	2
 222              	.L20:
 223 001c 00ED00E0 		.word	-536810240
 224              	.LBE27:
 225              	.LBE26:
 226              		.cfi_endproc
 227              	.LFE128:
 229              		.section	.text.HAL_PWR_EnterSTOPMode,"ax",%progbits
 230              		.align	1
 231              		.global	HAL_PWR_EnterSTOPMode
 232              		.thumb
 233              		.thumb_func
 235              	HAL_PWR_EnterSTOPMode:
 236              	.LFB129:
 309:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   {
 310:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****     /* Request Wait For Interrupt */
 311:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****     __WFI();
 312:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   }
 313:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   else
 314:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   {
 315:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****     /* Request Wait For Event */
 316:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****     __SEV();
 317:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****     __WFE();
 318:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****     __WFE();
 319:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   }
 320:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** }
 321:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 322:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** /**
 323:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @brief Enters STOP mode.
 324:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @note  In Stop mode, all I/O pins keep the same state as in Run mode.
 325:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @note  When exiting Stop mode by issuing an interrupt or a wakeup event,
 326:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *         the HSI RC oscillator is selected as system clock.
 327:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @note  When the voltage regulator operates in low power mode, an additional
 328:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *         startup delay is incurred when waking up from Stop mode.
 329:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *         By keeping the internal regulator ON during Stop mode, the consumption
 330:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *         is higher although the startup time is reduced.
 331:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @param Regulator Specifies the regulator state in STOP mode.
 332:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *          This parameter can be one of the following values:
 333:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *            @arg PWR_MAINREGULATOR_ON: STOP mode with regulator ON
 334:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *            @arg PWR_LOWPOWERREGULATOR_ON: STOP mode with low power regulator ON
 335:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @param STOPEntry specifies if STOP mode in entered with WFI or WFE instruction.
 336:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *          This parameter can be one of the following values:
 337:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *            @arg PWR_STOPENTRY_WFI:Enter STOP mode with WFI instruction
 338:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *            @arg PWR_STOPENTRY_WFE: Enter STOP mode with WFE instruction
 339:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @retval None
 340:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   */
 341:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** void HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
 342:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** {
 237              		.loc 1 342 0
 238              		.cfi_startproc
 239              		@ args = 0, pretend = 0, frame = 0
 240              		@ frame_needed = 0, uses_anonymous_args = 0
 241              		@ link register save eliminated.
 242              	.LVL5:
 343:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   uint32_t tmpreg = 0U;
 344:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 345:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   /* Check the parameters */
 346:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   assert_param(IS_PWR_REGULATOR(Regulator));
 347:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
 348:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 349:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   /* Select the regulator state in STOP mode ---------------------------------*/
 350:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   tmpreg = PWR->CR;
 243              		.loc 1 350 0
 244 0000 0B4B     		ldr	r3, .L25
 245 0002 1A68     		ldr	r2, [r3]
 246              	.LVL6:
 351:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   
 352:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   /* Clear PDDS and LPDS bits */
 353:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   tmpreg &= (uint32_t)~(PWR_CR_PDDS | PWR_CR_LPDS);
 247              		.loc 1 353 0
 248 0004 22F00302 		bic	r2, r2, #3
 249              	.LVL7:
 354:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 355:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   /* Set LPDS bit according to Regulator value */
 356:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   tmpreg |= Regulator;
 250              		.loc 1 356 0
 251 0008 1043     		orrs	r0, r0, r2
 252              	.LVL8:
 357:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 358:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   /* Store the new value */
 359:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   PWR->CR = tmpreg;
 253              		.loc 1 359 0
 254 000a 1860     		str	r0, [r3]
 360:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 361:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 362:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 255              		.loc 1 362 0
 256 000c 094B     		ldr	r3, .L25+4
 257 000e 1A69     		ldr	r2, [r3, #16]
 363:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 364:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   /* Select STOP mode entry --------------------------------------------------*/
 365:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   if(STOPEntry == PWR_STOPENTRY_WFI)
 258              		.loc 1 365 0
 259 0010 0129     		cmp	r1, #1
 362:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 260              		.loc 1 362 0
 261 0012 42F00402 		orr	r2, r2, #4
 262 0016 1A61     		str	r2, [r3, #16]
 263              		.loc 1 365 0
 264 0018 01D1     		bne	.L23
 265              	.LBB28:
 266              	.LBB29:
 385:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
 267              		.loc 2 385 0
 268              	@ 385 ".././hal/stm32f3/CMSIS/core/cmsis_gcc.h" 1
 269 001a 30BF     		wfi
 270              	@ 0 "" 2
 271              		.thumb
 272 001c 02E0     		b	.L24
 273              	.L23:
 274              	.LBE29:
 275              	.LBE28:
 276              	.LBB30:
 277              	.LBB31:
 278              		.loc 2 406 0
 279              	@ 406 ".././hal/stm32f3/CMSIS/core/cmsis_gcc.h" 1
 280 001e 40BF     		sev
 281              	@ 0 "" 2
 282              		.thumb
 283              	.LBE31:
 284              	.LBE30:
 285              	.LBB32:
 286              	.LBB33:
 396:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
 287              		.loc 2 396 0
 288              	@ 396 ".././hal/stm32f3/CMSIS/core/cmsis_gcc.h" 1
 289 0020 20BF     		wfe
 290              	@ 0 "" 2
 291              		.thumb
 292              	.LBE33:
 293              	.LBE32:
 294              	.LBB34:
 295              	.LBB35:
 296              	@ 396 ".././hal/stm32f3/CMSIS/core/cmsis_gcc.h" 1
 297 0022 20BF     		wfe
 298              	@ 0 "" 2
 299              		.thumb
 300              	.L24:
 301              	.LBE35:
 302              	.LBE34:
 366:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   {
 367:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****     /* Request Wait For Interrupt */
 368:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****     __WFI();
 369:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   }
 370:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   else
 371:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   {
 372:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****     /* Request Wait For Event */
 373:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****     __SEV();
 374:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****     __WFE();
 375:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****     __WFE();
 376:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   }
 377:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 378:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   /* Reset SLEEPDEEP bit of Cortex System Control Register */
 379:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
 303              		.loc 1 379 0
 304 0024 1A69     		ldr	r2, [r3, #16]
 305 0026 22F00402 		bic	r2, r2, #4
 306 002a 1A61     		str	r2, [r3, #16]
 307 002c 7047     		bx	lr
 308              	.L26:
 309 002e 00BF     		.align	2
 310              	.L25:
 311 0030 00700040 		.word	1073770496
 312 0034 00ED00E0 		.word	-536810240
 313              		.cfi_endproc
 314              	.LFE129:
 316              		.section	.text.HAL_PWR_EnterSTANDBYMode,"ax",%progbits
 317              		.align	1
 318              		.global	HAL_PWR_EnterSTANDBYMode
 319              		.thumb
 320              		.thumb_func
 322              	HAL_PWR_EnterSTANDBYMode:
 323              	.LFB130:
 380:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** }
 381:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 382:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** /**
 383:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @brief Enters STANDBY mode.
 384:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @note  In Standby mode, all I/O pins are high impedance except for:
 385:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *          - Reset pad (still available), 
 386:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *          - RTC alternate function pins if configured for tamper, time-stamp, RTC
 387:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *            Alarm out, or RTC clock calibration out, 
 388:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *          - WKUP pins if enabled.
 389:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @retval None
 390:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   */
 391:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** void HAL_PWR_EnterSTANDBYMode(void)
 392:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** {
 324              		.loc 1 392 0
 325              		.cfi_startproc
 326              		@ args = 0, pretend = 0, frame = 0
 327              		@ frame_needed = 0, uses_anonymous_args = 0
 328              		@ link register save eliminated.
 393:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   /* Select STANDBY mode */
 394:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   PWR->CR |= PWR_CR_PDDS;
 329              		.loc 1 394 0
 330 0000 054B     		ldr	r3, .L28
 331 0002 1A68     		ldr	r2, [r3]
 332 0004 42F00202 		orr	r2, r2, #2
 333 0008 1A60     		str	r2, [r3]
 395:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 396:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 397:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 334              		.loc 1 397 0
 335 000a 044B     		ldr	r3, .L28+4
 336 000c 1A69     		ldr	r2, [r3, #16]
 337 000e 42F00402 		orr	r2, r2, #4
 338 0012 1A61     		str	r2, [r3, #16]
 339              	.LBB36:
 340              	.LBB37:
 385:.././hal/stm32f3/CMSIS/core/cmsis_gcc.h **** }
 341              		.loc 2 385 0
 342              	@ 385 ".././hal/stm32f3/CMSIS/core/cmsis_gcc.h" 1
 343 0014 30BF     		wfi
 344              	@ 0 "" 2
 345              		.thumb
 346 0016 7047     		bx	lr
 347              	.L29:
 348              		.align	2
 349              	.L28:
 350 0018 00700040 		.word	1073770496
 351 001c 00ED00E0 		.word	-536810240
 352              	.LBE37:
 353              	.LBE36:
 354              		.cfi_endproc
 355              	.LFE130:
 357              		.section	.text.HAL_PWR_EnableSleepOnExit,"ax",%progbits
 358              		.align	1
 359              		.global	HAL_PWR_EnableSleepOnExit
 360              		.thumb
 361              		.thumb_func
 363              	HAL_PWR_EnableSleepOnExit:
 364              	.LFB131:
 398:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 399:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   /* This option is used to ensure that store operations are completed */
 400:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** #if defined ( __CC_ARM)
 401:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   __force_stores();
 402:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** #endif
 403:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   /* Request Wait For Interrupt */
 404:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   __WFI();
 405:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** }
 406:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 407:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** /**
 408:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @brief Indicates Sleep-On-Exit when returning from Handler mode to Thread mode. 
 409:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @note Set SLEEPONEXIT bit of SCR register. When this bit is set, the processor 
 410:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *       re-enters SLEEP mode when an interruption handling is over.
 411:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *       Setting this bit is useful when the processor is expected to run only on
 412:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *       interruptions handling.         
 413:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @retval None
 414:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   */
 415:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** void HAL_PWR_EnableSleepOnExit(void)
 416:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** {
 365              		.loc 1 416 0
 366              		.cfi_startproc
 367              		@ args = 0, pretend = 0, frame = 0
 368              		@ frame_needed = 0, uses_anonymous_args = 0
 369              		@ link register save eliminated.
 417:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   /* Set SLEEPONEXIT bit of Cortex System Control Register */
 418:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
 370              		.loc 1 418 0
 371 0000 024B     		ldr	r3, .L31
 372 0002 1A69     		ldr	r2, [r3, #16]
 373 0004 42F00202 		orr	r2, r2, #2
 374 0008 1A61     		str	r2, [r3, #16]
 375 000a 7047     		bx	lr
 376              	.L32:
 377              		.align	2
 378              	.L31:
 379 000c 00ED00E0 		.word	-536810240
 380              		.cfi_endproc
 381              	.LFE131:
 383              		.section	.text.HAL_PWR_DisableSleepOnExit,"ax",%progbits
 384              		.align	1
 385              		.global	HAL_PWR_DisableSleepOnExit
 386              		.thumb
 387              		.thumb_func
 389              	HAL_PWR_DisableSleepOnExit:
 390              	.LFB132:
 419:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** }
 420:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 421:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 422:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** /**
 423:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @brief Disables Sleep-On-Exit feature when returning from Handler mode to Thread mode. 
 424:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @note Clears SLEEPONEXIT bit of SCR register. When this bit is set, the processor 
 425:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *       re-enters SLEEP mode when an interruption handling is over.          
 426:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @retval None
 427:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   */
 428:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** void HAL_PWR_DisableSleepOnExit(void)
 429:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** {
 391              		.loc 1 429 0
 392              		.cfi_startproc
 393              		@ args = 0, pretend = 0, frame = 0
 394              		@ frame_needed = 0, uses_anonymous_args = 0
 395              		@ link register save eliminated.
 430:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   /* Clear SLEEPONEXIT bit of Cortex System Control Register */
 431:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
 396              		.loc 1 431 0
 397 0000 024B     		ldr	r3, .L34
 398 0002 1A69     		ldr	r2, [r3, #16]
 399 0004 22F00202 		bic	r2, r2, #2
 400 0008 1A61     		str	r2, [r3, #16]
 401 000a 7047     		bx	lr
 402              	.L35:
 403              		.align	2
 404              	.L34:
 405 000c 00ED00E0 		.word	-536810240
 406              		.cfi_endproc
 407              	.LFE132:
 409              		.section	.text.HAL_PWR_EnableSEVOnPend,"ax",%progbits
 410              		.align	1
 411              		.global	HAL_PWR_EnableSEVOnPend
 412              		.thumb
 413              		.thumb_func
 415              	HAL_PWR_EnableSEVOnPend:
 416              	.LFB133:
 432:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** }
 433:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 434:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 435:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 436:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** /**
 437:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @brief Enables CORTEX M4 SEVONPEND bit. 
 438:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @note Sets SEVONPEND bit of SCR register. When this bit is set, this causes 
 439:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *       WFE to wake up when an interrupt moves from inactive to pended.
 440:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @retval None
 441:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   */
 442:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** void HAL_PWR_EnableSEVOnPend(void)
 443:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** {
 417              		.loc 1 443 0
 418              		.cfi_startproc
 419              		@ args = 0, pretend = 0, frame = 0
 420              		@ frame_needed = 0, uses_anonymous_args = 0
 421              		@ link register save eliminated.
 444:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   /* Set SEVONPEND bit of Cortex System Control Register */
 445:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
 422              		.loc 1 445 0
 423 0000 024B     		ldr	r3, .L37
 424 0002 1A69     		ldr	r2, [r3, #16]
 425 0004 42F01002 		orr	r2, r2, #16
 426 0008 1A61     		str	r2, [r3, #16]
 427 000a 7047     		bx	lr
 428              	.L38:
 429              		.align	2
 430              	.L37:
 431 000c 00ED00E0 		.word	-536810240
 432              		.cfi_endproc
 433              	.LFE133:
 435              		.section	.text.HAL_PWR_DisableSEVOnPend,"ax",%progbits
 436              		.align	1
 437              		.global	HAL_PWR_DisableSEVOnPend
 438              		.thumb
 439              		.thumb_func
 441              	HAL_PWR_DisableSEVOnPend:
 442              	.LFB134:
 446:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** }
 447:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 448:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** 
 449:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** /**
 450:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @brief Disables CORTEX M4 SEVONPEND bit. 
 451:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @note Clears SEVONPEND bit of SCR register. When this bit is set, this causes 
 452:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   *       WFE to wake up when an interrupt moves from inactive to pended.         
 453:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   * @retval None
 454:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   */
 455:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** void HAL_PWR_DisableSEVOnPend(void)
 456:.././hal/stm32f3/stm32f3xx_hal_pwr.c **** {
 443              		.loc 1 456 0
 444              		.cfi_startproc
 445              		@ args = 0, pretend = 0, frame = 0
 446              		@ frame_needed = 0, uses_anonymous_args = 0
 447              		@ link register save eliminated.
 457:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   /* Clear SEVONPEND bit of Cortex System Control Register */
 458:.././hal/stm32f3/stm32f3xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
 448              		.loc 1 458 0
 449 0000 024B     		ldr	r3, .L40
 450 0002 1A69     		ldr	r2, [r3, #16]
 451 0004 22F01002 		bic	r2, r2, #16
 452 0008 1A61     		str	r2, [r3, #16]
 453 000a 7047     		bx	lr
 454              	.L41:
 455              		.align	2
 456              	.L40:
 457 000c 00ED00E0 		.word	-536810240
 458              		.cfi_endproc
 459              	.LFE134:
 461              		.text
 462              	.Letext0:
 463              		.file 3 "/usr/include/newlib/machine/_default_types.h"
 464              		.file 4 "/usr/include/newlib/stdint.h"
 465              		.file 5 ".././hal/stm32f3/CMSIS/core/core_cm4.h"
 466              		.file 6 ".././hal/stm32f3/CMSIS/device/stm32f303x8.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stm32f3xx_hal_pwr.c
     /tmp/ccwi1jvL.s:21     .text.HAL_PWR_DeInit:00000000 $t
     /tmp/ccwi1jvL.s:26     .text.HAL_PWR_DeInit:00000000 HAL_PWR_DeInit
     /tmp/ccwi1jvL.s:47     .text.HAL_PWR_DeInit:00000014 $d
     /tmp/ccwi1jvL.s:52     .text.HAL_PWR_EnableBkUpAccess:00000000 $t
     /tmp/ccwi1jvL.s:57     .text.HAL_PWR_EnableBkUpAccess:00000000 HAL_PWR_EnableBkUpAccess
     /tmp/ccwi1jvL.s:73     .text.HAL_PWR_EnableBkUpAccess:0000000c $d
     /tmp/ccwi1jvL.s:78     .text.HAL_PWR_DisableBkUpAccess:00000000 $t
     /tmp/ccwi1jvL.s:83     .text.HAL_PWR_DisableBkUpAccess:00000000 HAL_PWR_DisableBkUpAccess
     /tmp/ccwi1jvL.s:99     .text.HAL_PWR_DisableBkUpAccess:0000000c $d
     /tmp/ccwi1jvL.s:104    .text.HAL_PWR_EnableWakeUpPin:00000000 $t
     /tmp/ccwi1jvL.s:109    .text.HAL_PWR_EnableWakeUpPin:00000000 HAL_PWR_EnableWakeUpPin
     /tmp/ccwi1jvL.s:127    .text.HAL_PWR_EnableWakeUpPin:0000000c $d
     /tmp/ccwi1jvL.s:132    .text.HAL_PWR_DisableWakeUpPin:00000000 $t
     /tmp/ccwi1jvL.s:137    .text.HAL_PWR_DisableWakeUpPin:00000000 HAL_PWR_DisableWakeUpPin
     /tmp/ccwi1jvL.s:155    .text.HAL_PWR_DisableWakeUpPin:0000000c $d
     /tmp/ccwi1jvL.s:160    .text.HAL_PWR_EnterSLEEPMode:00000000 $t
     /tmp/ccwi1jvL.s:165    .text.HAL_PWR_EnterSLEEPMode:00000000 HAL_PWR_EnterSLEEPMode
     /tmp/ccwi1jvL.s:223    .text.HAL_PWR_EnterSLEEPMode:0000001c $d
     /tmp/ccwi1jvL.s:230    .text.HAL_PWR_EnterSTOPMode:00000000 $t
     /tmp/ccwi1jvL.s:235    .text.HAL_PWR_EnterSTOPMode:00000000 HAL_PWR_EnterSTOPMode
     /tmp/ccwi1jvL.s:311    .text.HAL_PWR_EnterSTOPMode:00000030 $d
     /tmp/ccwi1jvL.s:317    .text.HAL_PWR_EnterSTANDBYMode:00000000 $t
     /tmp/ccwi1jvL.s:322    .text.HAL_PWR_EnterSTANDBYMode:00000000 HAL_PWR_EnterSTANDBYMode
     /tmp/ccwi1jvL.s:350    .text.HAL_PWR_EnterSTANDBYMode:00000018 $d
     /tmp/ccwi1jvL.s:358    .text.HAL_PWR_EnableSleepOnExit:00000000 $t
     /tmp/ccwi1jvL.s:363    .text.HAL_PWR_EnableSleepOnExit:00000000 HAL_PWR_EnableSleepOnExit
     /tmp/ccwi1jvL.s:379    .text.HAL_PWR_EnableSleepOnExit:0000000c $d
     /tmp/ccwi1jvL.s:384    .text.HAL_PWR_DisableSleepOnExit:00000000 $t
     /tmp/ccwi1jvL.s:389    .text.HAL_PWR_DisableSleepOnExit:00000000 HAL_PWR_DisableSleepOnExit
     /tmp/ccwi1jvL.s:405    .text.HAL_PWR_DisableSleepOnExit:0000000c $d
     /tmp/ccwi1jvL.s:410    .text.HAL_PWR_EnableSEVOnPend:00000000 $t
     /tmp/ccwi1jvL.s:415    .text.HAL_PWR_EnableSEVOnPend:00000000 HAL_PWR_EnableSEVOnPend
     /tmp/ccwi1jvL.s:431    .text.HAL_PWR_EnableSEVOnPend:0000000c $d
     /tmp/ccwi1jvL.s:436    .text.HAL_PWR_DisableSEVOnPend:00000000 $t
     /tmp/ccwi1jvL.s:441    .text.HAL_PWR_DisableSEVOnPend:00000000 HAL_PWR_DisableSEVOnPend
     /tmp/ccwi1jvL.s:457    .text.HAL_PWR_DisableSEVOnPend:0000000c $d
                     .debug_frame:00000010 $d

NO UNDEFINED SYMBOLS
